# Achronyme Codebase Audit — 2026-02-23

Full-project audit at commit `ca8b156` (679 tests passing, 7 crates).
Covers: compiler warnings, test coverage, error handling, architecture.

> **Revision 1**: C-01, C-02, H-01, H-02, H-03 reclassified as false positives
> after manual verification. See "Dismissed Findings" appendix for details.

---

## Summary

| Severity | Open | False Positive |
|----------|------|----------------|
| Critical | 0 | 2 (C-01, C-02) |
| High | 2 | 3 (H-01, H-02, H-03) |
| Medium | 8 | 0 |
| Low | 12 | 0 |

---

## High (2 confirmed)

### H-04: CLI commands without tests

- **Issue**: `compile`, `disassemble`, `run`, `repl` commands have zero test coverage — no unit tests, no integration tests, no `cli/tests/` directory.
- **Files**: `cli/src/commands/compile.rs`, `cli/src/commands/run.rs`, `cli/src/commands/disassemble.rs`, `cli/src/repl.rs`
- **Note**: `circuit` command has 6 inline tests for `parse_inputs()` helper only; the main `circuit_command()` function is untested.
- **Fix**: Add integration tests that invoke each command programmatically.

### H-05: Error type degradation in prove pipeline

- **Files**: `compiler/src/r1cs_error.rs:24`, `cli/src/prove_handler.rs:49,81,100,105`
- **Issue**: Structured error types are converted to opaque strings **before** the display boundary:
  - `ir::eval::EvalError` (7 variants with var names, values, spans) → `R1CSError::EvalError(String)` via `format!("{e}")`
  - `IrError` (13 variants with source spans) → `String` in prove_handler
  - `R1CSError` → `String` in prove_handler (2 instances)
  - `PlonkishError` → `String` in prove_handler
- **Root cause**: `ProveHandler` trait forces `Result<ProveResult, String>`, so all implementors must stringify errors.
- **Impact**: VM receives `RuntimeError::ProveBlockFailed(String)` — cannot pattern-match for recovery, specialized diagnostics, or error codes.
- **Fix**: Change `ProveHandler` trait to use a typed error enum (e.g., `ProveError`); convert to strings only at CLI display boundary. Total: 4 `.map_err(|e| format!(...))` instances to refactor.

---

## Medium (8)

### M-01: `freed_bytes` dead code in heap GC

- **File**: `memory/src/heap.rs:415-537`
- **Issue**: Variable `freed_bytes` is assigned across 10 sites in `Heap::sweep()` but its final value is never read. Abandoned instrumentation.
- **Fix**: Remove the variable and all accumulations, or return it as a metric.

### M-02: Unused `pest` dependency in compiler crate

- **File**: `compiler/Cargo.toml:12`
- **Issue**: `pest = "2.6"` listed as dependency but no `use pest` exists in `compiler/src/`. All parsing goes through `achronyme-parser`. Adds unnecessary build time.
- **Fix**: Remove the dependency.

### M-03: `circuit_command()` has 10 parameters

- **File**: `cli/src/commands/circuit.rs:39`
- **Parameters**: `path`, `r1cs_path`, `wtns_path`, `public`, `witness`, `inputs`, `no_optimize`, `backend`, `prove`, `solidity_path`.
- **Issue**: Exceeds the 7-parameter limit; hard to maintain and test.
- **Fix**: Introduce a `CircuitOpts` struct.

### M-04: Duplicated `compile_ir()` across backends

- **Files**: `compiler/src/r1cs_backend.rs:226` (~341 lines), `compiler/src/plonkish_backend.rs:152` (~331 lines)
- **Issue**: Both walk the same 19 IR instruction variants with massive match statements. Logic differs only in backend-specific value representation.
- **Fix**: Extract a shared IR walker trait or visitor pattern; backends implement only the backend-specific operations.

### M-05: 10 types with `new()` but no `Default` impl

- **Types**: `VM`, `Heap`, `Arena`, `ConstraintSystem`, `IrProgram`, `IrLowering`, `Compiler`, `StringInterner`, `R1CSCompiler`, `PlonkishCompiler`.
- **Fix**: `#[derive(Default)]` or manual impl delegating to `new()`.

### M-06: `Expression` methods shadow Ops traits

- **File**: `constraints/src/plonkish.rs:61-75`
- **Issue**: `add()`, `mul()`, `sub()`, `neg()` are plain methods, not `std::ops` trait implementations. Users expect `+` to work.
- **Fix**: Implement `Add`, `Sub`, `Mul`, `Neg` traits; remove or rename manual methods.

### M-07: `unreachable!()` in VM dispatch handlers

- **Files**: `vm/src/machine/data.rs:202`, `vm/src/machine/control.rs:115`, `vm/src/machine/globals.rs:110`, `vm/src/machine/arithmetic.rs:251`
- **Issue**: 4 `unreachable!()` calls in opcode dispatch. If a new opcode is added to the wrong handler group, the VM panics instead of returning an error.
- **Fix**: Replace with `_ => Err(RuntimeError::Unknown("unexpected opcode in <handler>"))`.

### M-08: Fragile lazy init pattern for Poseidon params

- **Files**: `compiler/src/r1cs_backend.rs:525-529`, `compiler/src/plonkish_backend.rs:820-823`
- **Pattern**: `if self.poseidon_params.is_none() { ... } let params = self.poseidon_params.as_ref().unwrap();`
- **Issue**: If the check and unwrap drift apart during refactoring, it panics.
- **Fix**: Use `self.poseidon_params.get_or_insert_with(|| PoseidonParams::bn254_t3())`.

---

## Low (~89 clippy warnings)

### L-01: Loop variable indexing (22 instances)

- **Files**: `constraints/src/poseidon.rs` (12), `compiler/src/plonkish_backend.rs` (3), `compiler/src/witness_gen.rs` (4), `ir/src/passes/const_fold.rs` (1), `cli/src/halo2_proof.rs` (2)
- **Issue**: `for i in 0..len { arr[i] }` should use iterators with `.enumerate()` or `.iter_mut()`.
- **Fix**: `cargo clippy --fix` handles most cases.

### L-02: Empty lines after doc comments (6 files)

- **Files**: `achronyme-parser/src/ast.rs:4`, `constraints/src/export.rs:4`, `constraints/src/plonkish.rs:9`, `constraints/src/poseidon.rs:33`, `constraints/src/r1cs.rs:10`, `constraints/src/witness.rs:4`
- **Fix**: Remove blank line between `///` and item.

### L-03: `manual_range_contains` (5 instances)

- **File**: `vm/src/machine/arithmetic.rs:42,72,101,189,230`
- **Pattern**: `result >= I60_MIN && result <= I60_MAX` should be `(I60_MIN..=I60_MAX).contains(&result)`.

### L-04: Redundant closures (5 instances)

- **Files**: `ir/src/lower.rs:125,178`, `cli/src/groth16.rs:251`, `cli/src/halo2_proof.rs:469,481`
- **Pattern**: `.map_err(|e| IrError::ParseError(e))` should be `.map_err(IrError::ParseError)`.

### L-05: Unnecessary casts (2 instances)

- **Files**: `memory/src/field.rs:406` (`u64 as u64`), `compiler/src/r1cs_backend.rs:345` (`i as u32` already u32).

### L-06: `clone_on_copy`

- **File**: `vm/src/machine/globals.rs:71`
- **Issue**: `.clone()` on `Value` which is `Copy`.

### L-07: Unused import

- **File**: `ir/src/passes/dce.rs:3`
- **Issue**: `Instruction` imported but never used.

### L-08: `map_or(false, ...)` patterns (9 instances)

- **File**: `ir/src/passes/const_fold.rs:34,39,60,76,77,118,119,239,240`
- **Fix**: Replace with `.is_some_and(|v| ...)`.

### L-09: `manual_div_ceil`

- **File**: `constraints/src/poseidon.rs:463`
- **Pattern**: `(field_size + 7) / 8` should be `field_size.div_ceil(8)`.

### L-10: `derivable_impls`

- **File**: `cli/src/halo2_proof.rs:64`
- **Issue**: Manual `Default` impl can be `#[derive(Default)]`.

### L-11: `get_first`

- **File**: `cli/src/halo2_proof.rs:308`
- **Pattern**: `.get(0)` should be `.first()`.

### L-12: Large error types

- **Files**: `achronyme-parser/src/lib.rs:16` (`pest::error::Error<Rule>` ~272 bytes), `ir/src/eval.rs:128` (`EvalError` ~136 bytes)
- **Issue**: Large `Err` variants increase stack usage in `Result` types.
- **Fix**: Consider `Box<pest::error::Error<Rule>>` for the parser error.

---

## Positive Findings

- Zero `unsafe` code blocks
- Zero `TODO` / `FIXME` / `HACK` comments
- Zero circular dependencies between crates
- Clean 7-crate architecture with proper layering
- 679 tests passing across the workspace
- Well-implemented optimization passes (const_fold, dce, bool_prop, taint)
- Consistent use of `?` operator and `Result` propagation in most code
- Good CLI error handling with `anyhow::Context`

---

## Metrics

| Crate | Source Lines | Test Lines | Warnings |
|-------|-------------|------------|----------|
| `achronyme-parser` | ~2,500 | ~400 | 2 |
| `memory` | ~3,200 | ~600 | 13 |
| `constraints` | ~4,800 | ~500 | 23 |
| `ir` | ~3,500 | ~1,200 | 18 |
| `compiler` | ~6,500 | ~6,300 | 16 |
| `vm` | ~4,800 | ~2,000 | 7 |
| `cli` | ~3,500 | ~200 | 8 |
| **Total** | **~28,800** | **~11,200** | **87** |

---

## Appendix: Dismissed Findings

### C-01: `panic!()` in `LinearCombination::evaluate()` — FALSE POSITIVE

- **File**: `constraints/src/r1cs.rs:142-148`
- **Original claim**: Production panic on malformed witness data.
- **Verification**: `verify()` checks `witness.len() == num_variables` before calling `evaluate()`. All `Variable` indices are allocated via `alloc_input/alloc_witness` which monotonically increment within `num_variables`. The panic is an invariant assertion that cannot be reached with user-provided data through any normal code path.

### C-02: Groth16 setup `unwrap()` calls — FALSE POSITIVE

- **Files**: `cli/src/solidity.rs:289,365`, `cli/src/groth16.rs:289`
- **Original claim**: 3 crypto ceremony unwraps in production code.
- **Verification**: Both instances in `solidity.rs` are inside `#[cfg(test)]` modules with hardcoded deterministic circuits that cannot fail. The third reference (`groth16.rs:289`) does not exist — production code at `groth16.rs:123,152` already uses `.map_err(|e| ...)?` correctly.

### H-01: 40+ `unwrap()` calls in `build_ast.rs` — FALSE POSITIVE (fragile, not buggy)

- **File**: `achronyme-parser/src/build_ast.rs`
- **Original claim**: Grammar changes will crash the parser.
- **Verification**: Exact count is 38 unwraps. All 34 pest `.next().unwrap()` calls are safe because pest's PEG parser guarantees the Pair structure matches the grammar rule — if a rule says `A ~ B`, `into_inner()` always yields exactly those children. The 4 non-pest unwraps are similarly grammar-guaranteed. **However**, this creates coupling: a grammar change without a matching `build_ast.rs` update would panic at runtime, not compile time. This fragility will be eliminated by the planned handwritten parser migration.

### H-02: Untested native functions — FALSE POSITIVE (mostly)

- **Original claim**: 11 of 20 natives lack tests.
- **Verification**: 10 of the 11 listed functions have test coverage. `field()` is tested extensively in `vm/tests/prove_test.rs`. `assert()` is tested in `compiler/tests/r1cs_ir_test.rs` and `plonkish_test.rs`. All 8 string natives are tested in `vm/tests/string_tests.rs`. **Only `time()` genuinely lacks tests** — it's a trivial wrapper around `SystemTime::now()` with no meaningful failure mode.

### H-03: Untested `FieldElement` methods — FALSE POSITIVE

- **File**: `memory/src/field.rs`
- **Original claim**: `from_hex_str()`, `pow()`, `inv()` have no tests.
- **Verification**: All three have direct unit tests in `memory/src/field.rs`: `test_from_hex_str()` (line 642), `test_pow()` (line 615), `test_inverse()` (line 588), plus cross-validation vector tests (`test_vector_pow_42_10`, `test_vector_inv7`). `inv()` is also tested indirectly through every division test in the compiler and IR test suites.
