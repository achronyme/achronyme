---
title: "Memory & GC"
description: "Typed arenas, mark-and-sweep garbage collection, and stress testing."
---

Achronyme manages heap memory through **typed arenas** with a **mark-and-sweep** garbage collector. All heap objects are allocated in type-specific pools and reclaimed when no longer reachable.

## Typed Arenas

The `Heap` contains 9 typed arenas, one per heap object type:

| Arena | Type | Allocation Size |
|-------|------|-----------------|
| `strings` | `String` | `capacity()` bytes |
| `lists` | `Vec<Value>` | `capacity() × 8` bytes |
| `maps` | `HashMap<String, Value>` | `capacity × (string + value + 8)` bytes |
| `functions` | `Function` | `chunk.len() × 4 + constants.len() × 8` bytes |
| `closures` | `Closure` | function handle + upvalue handles |
| `upvalues` | `Upvalue` | location + linked list pointer |
| `iterators` | `IteratorObj` | source value + state |
| `fields` | `FieldElement` | 32 bytes (BN254 Montgomery form) |
| `proofs` | `ProofObject` | 3 JSON strings (proof + public + vkey) |

### Arena Implementation

Each `Arena<T>` uses a slot-based allocator with free list recycling:

```
Arena<T> {
    data: Vec<T>,           // grows monotonically
    free_indices: Vec<u32>, // reusable slot stack
    free_set: HashSet<u32>, // O(1) membership check
}
```

**Allocation** (`alloc`): reuses a freed slot if available, otherwise appends to `data`.

**Deallocation** (`mark_free`): adds the slot index to the free list. The slot is zeroed to release memory (e.g., `String::new()`, `Vec::new()`).

**Invariant**: `free_indices` and `free_set` must always stay in sync.

## Garbage Collection

The GC is a stop-the-world **mark-and-sweep** collector.

### Trigger

The heap tracks live allocation size in `bytes_allocated`. When it exceeds `next_gc_threshold` (starting at 1 MB), the GC is triggered:

```
if heap.request_gc || stress_mode {
    collect_garbage();
}
```

This check runs at the start of every interpreter cycle (before executing the next instruction).

### Mark Phase

Breadth-first traversal from roots using a worklist:

1. **Collect roots**:
   - All values on the VM stack (65,536 slots)
   - All global variables
   - All call frame closures
   - All function prototypes (stay alive for closure creation)

2. **Traverse children**:
   - **List**: all elements are added to worklist
   - **Function**: all constants are added to worklist
   - **Closure**: marks function handle + all upvalues; closed upvalues add their captured value to worklist
   - **Map**: all values are added (keys are Rust-owned, freed when HashMap drops)
   - **Iterator**: source value is added
   - **Field, Proof**: leaf types, no children

3. **Root open upvalues**: After the main trace, all open upvalues are explicitly marked via the linked list traversal. This prevents premature collection of stack variables captured by closures.

Each arena type has its own `HashSet<u32>` of marked indices. If an object is already marked, it is skipped (prevents infinite loops on cycles).

### Sweep Phase

Linear scan over each arena:

1. For each slot in `data`:
   - If **not marked** and **not already free**: zero the slot and add to free list
   - If **marked**: leave in place
2. Clear all marked sets
3. Recount `bytes_allocated` from scratch (eliminates tracking drift from in-place mutations like `Vec::push`)

### Threshold Adjustment

After sweeping, the threshold is recalculated with hysteresis:

```
grow = bytes_allocated × 2
hysteresis = previous_threshold × 1.5
next_gc_threshold = max(grow, hysteresis, 1 MB)
```

This prevents GC thrashing when the heap size hovers near the old threshold.

## Stress GC Mode

Run with `--stress-gc` to force garbage collection on every interpreter cycle:

```bash
ach run program.ach --stress-gc
```

This triggers `collect_garbage()` before every instruction, exposing:
- **Dangling pointers**: objects freed while still referenced
- **Rooting bugs**: roots not properly tracked (e.g., open upvalues)
- **Timing-dependent bugs**: issues that only appear under specific GC timing

Stress mode is used extensively in the test suite (`vm.stress_mode = true`) to verify GC correctness.

## Key Heap Objects

### Closure

```
Closure {
    function: u32,       // handle to Function
    upvalues: Vec<u32>,  // handles to Upvalue arena
}
```

### Upvalue

```
Upvalue {
    location: Open(stack_index) | Closed(Value),
    next_open: Option<u32>,  // linked list for open upvalues
}
```

**Open** upvalues point to a stack slot — the variable is still in scope. When the enclosing function returns, open upvalues are **closed**: the value is copied from the stack into the upvalue (`Closed(value)`), and the upvalue is removed from the open list.

### ProofObject

```
ProofObject {
    proof_json: String,   // Groth16 proof data
    public_json: String,  // public inputs
    vkey_json: String,     // verification key
}
```

Created by `prove {}` blocks. Accessible via `proof_json()`, `proof_public()`, `proof_vkey()`.

## Source Files

| Component | File |
|-----------|------|
| Heap & Arena | `memory/src/heap.rs` |
| Value encoding | `memory/src/value.rs` |
| FieldElement | `memory/src/field.rs` |
| GC trait | `vm/src/machine/gc.rs` |
| VM (GC trigger) | `vm/src/machine/vm.rs` |
