# Achronyme VM Bytecode Compiler — Bug Report

**Date**: 2026-02-22
**Scope**: Bytecode compiler (`compiler/`) and VM runtime (`vm/`)
**Method**: Black-box testing via `.ach` test suite (`test/*.ach`)
**Status**: Open — workarounds applied in test suite, no compiler fixes

---

## Summary

| Severity | Count |
|----------|-------|
| HIGH     | 3     |
| MEDIUM   | 3     |
| LOW      | 1     |
| **Total** | **7** |

---

## Findings

### B-01 — `^` power operator not functional in bytecode path

| Field | Value |
|-------|-------|
| **Severity** | HIGH |
| **Crate** | `compiler` |
| **File** | `compiler/src/expressions/postfix.rs:20` |
| **Reproducer** | `assert(2 ^ 10 == 1024)` |
| **Error** | `UnexpectedRule("Postfix: pow_op")` |

**Root cause**: `compile_prefix()` passes the last child of `prefix_expr` (which is a `pow_expr`) directly to `compile_postfix()`. When the `pow_expr` contains the `^` operator (e.g., `2 ^ 10`), its children include `pow_op` nodes. `compile_postfix()` doesn't recognize `pow_op` and errors out via its catch-all.

The grammar defines: `prefix_expr = { unary_op* ~ pow_expr }`. The fix is to change `self.compile_postfix(expr_pair)` to `self.compile_expr(expr_pair)` at line 20, which would correctly route `pow_expr` to `compile_binary`.

**Note**: The VM's `OpCode::Pow` handler (`vm/src/machine/arithmetic.rs:138-180`) is fully implemented for int, float, and field types. Only the bytecode compiler routing is broken.

**Workaround**: Avoid `^` operator; use repeated multiplication.

---

### B-02 — `fn_decl` statement not handled by bytecode compiler

| Field | Value |
|-------|-------|
| **Severity** | HIGH |
| **Crate** | `compiler` |
| **File** | `compiler/src/statements/mod.rs:17-68` |
| **Reproducer** | `fn add(a, b) { return a + b }` |
| **Error** | `UnexpectedRule("fn_decl")` |

**Root cause**: The grammar accepts `fn_decl` as a statement (`stmt` rule includes `fn_decl`), but the bytecode statement compiler's `compile_stmt` match has no arm for `Rule::fn_decl`. It falls through to the catch-all error.

The `fn_expr` path (`let f = fn(a, b) { ... }`) works correctly via the atom compiler.

**Workaround**: Use `let f = fn f(a, b) { ... }` instead of `fn f(a, b) { ... }`.

---

### B-03 — `for..in` loop register double-free panic

| Field | Value |
|-------|-------|
| **Severity** | HIGH |
| **Crate** | `compiler` |
| **File** | `compiler/src/control_flow.rs:201-248` |
| **Reproducer** | `for item in [1, 2, 3] { print(item) }` |
| **Error** | `assertion failed: Register Hygiene Error` (panic at `function_compiler.rs:72`) |

**Root cause**: `compile_for()` allocates `val_reg` (line 211), registers the loop variable as a scoped local bound to `val_reg` (line 222), then at cleanup:
1. `end_scope()` (line 237) pops the local and calls `free_reg(val_reg)` via `scopes.rs:38`
2. Explicit `free_reg(val_reg)` at line 239

This is a double-free. The assertion at `function_compiler.rs:72` catches the mismatch.

**Fix**: Remove the explicit `free_reg(val_reg)` at line 239 — `end_scope()` already handles it.

**Workaround**: Use `while` loops with manual index management.

---

### B-04 — `else if` chains cause register hygiene panic

| Field | Value |
|-------|-------|
| **Severity** | MEDIUM |
| **Crate** | `compiler` |
| **File** | `compiler/src/control_flow.rs` (compile_if) |
| **Reproducer** | `if false { 1 } else if true { 2 } else { 3 }` |
| **Error** | `assertion failed: Register Hygiene Error` (panic at `function_compiler.rs:72`) |

**Root cause**: The `else if` grammar rule (`if_expr = { "if" ~ expr ~ block ~ ("else" ~ (block | if_expr))? }`) nests a recursive `if_expr` inside the else branch. The bytecode compiler's `compile_if` likely doesn't handle register allocation correctly for the recursive case, leading to a register count mismatch.

**Workaround**: Use nested `if/else` blocks: `if a { ... } else { if b { ... } else { ... } }`.

---

### B-05 — String concatenation with `+` not supported

| Field | Value |
|-------|-------|
| **Severity** | MEDIUM |
| **Crate** | `vm` |
| **File** | `vm/src/machine/arithmetic.rs:53-57`, `vm/src/machine/promotion.rs:34-96` |
| **Reproducer** | `"hello" + " world"` |
| **Error** | `RuntimeError: TypeMismatch("Operands must be numeric")` |

**Root cause**: The `Add` opcode handler uses the `binary_arithmetic_op!` macro, which dispatches on `TAG_INT`, `TAG_NUMBER`, and `TAG_FIELD` only. String values fall through to the catch-all error. There is no `Concat` opcode or string-aware branch anywhere in the arithmetic pipeline.

**Impact**: No way to concatenate strings at runtime.

---

### B-06 — Identifier names starting with keywords are misparsed

| Field | Value |
|-------|-------|
| **Severity** | MEDIUM |
| **Crate** | `achronyme-parser` |
| **File** | `achronyme-parser/src/grammar.pest` (stmt rule, lines 187-199) |
| **Reproducer** | `mut letter = "F"; letter = "B"; print(letter)` → prints `F` (mutation lost) |
| **Error** | Silent misparse — no error, incorrect behavior |

**Root cause**: In the `stmt` rule, `let_decl` is tried before `assignment`. When the parser encounters `letter = "B"`, it matches:
- `"let"` → first 3 chars of `letter`
- `ter` → parsed as `identifier`
- `= "B"` → parsed as initializer

So `letter = "B"` is silently parsed as `let ter = "B"` (a new immutable binding), not as a reassignment to `letter`.

The `keyword` rule uses a negative lookahead (`!(ASCII_ALPHANUMERIC | "_")`), but the PEG ordered choice in `stmt` tries `let_decl` first, and `let_decl` starts with the string literal `"let"` which greedily matches the prefix of `letter`.

**Affected identifiers**: Any name starting with a keyword prefix: `letter`, `letting`, `format`, `fortune`, `while_loop`, `forever_more`, `nil_value`, `true_flag`, `false_alarm`, `return_val`, `break_point`, `continue_flag`, `public_key`, `witness_data`, `prove_it`, `printing`, `mutation`, etc.

**Workaround**: Avoid variable names that start with reserved keywords.

---

### B-07 — `typeof(fn() {})` returns `"Unknown"` instead of `"Function"`

| Field | Value |
|-------|-------|
| **Severity** | LOW |
| **Crate** | `vm` |
| **File** | `vm/src/stdlib/core.rs:114-155` |
| **Reproducer** | `let f = fn() {}; print(typeof(f))` → `Unknown` |
| **Expected** | `"Function"` |

**Root cause**: The `typeof` native function's type tag dispatch doesn't match the tag used for closure/function values created by `fn() {}` expressions. The value likely gets a tag that isn't handled, falling through to `"Unknown"`.

**Note**: `typeof(fn() { return 1 })` also returns `"Unknown"`. The `print` native correctly returns `"Native"`, confirming that native functions use a different tag path.

---

## Additional Notes

- All 7 bugs were discovered during creation of the `test/` integration test suite
- The test suite (12 files, all passing) works around all issues listed above
- The `^` operator, `for..in` loops, `else if` chains, and `fn` declarations all work correctly through the IR/circuit pipeline — these bugs are specific to the bytecode compiler path
- `print` is grammar-level keyword (not a first-class value) — `typeof(print)` is a parse error, not a bug
- `{}` parses as empty map literal (not empty block) due to PEG ordered choice — by design
