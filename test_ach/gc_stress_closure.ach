fn create_chain(n) {
    if n == 0 { return fn() { return 0; }; }
    mut next = create_chain(n - 1);
    // Captures 'next', forcing a heap allocation for the closure and upvalue
    return fn() { return next() + 1; };
}

mut i = 0;
while i < 10 {
    // Reduced loop for visible output, but keep complexity
    create_chain(50); 
    i = i + 1;
}
print("THE GAUNTLET HAS BEEN SURVIVED.");
