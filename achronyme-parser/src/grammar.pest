// ============================================================================
// Achronyme Core Grammar - Foundation V1
// ============================================================================
//
// OPERATOR PRECEDENCE (highest to lowest):
//
//   Prec  Operator       Assoc   Description
//   ----  --------       -----   -----------
//   1     () [] .        left    Call, index, dot access (postfix)
//   2     ^              right   Exponentiation
//   3     - !            right   Negation, logical NOT (prefix)
//   4     * / %          left    Multiplication, division, modulo
//   5     + -            left    Addition, subtraction
//   6     == != < <= > >=  —     Comparison (single, no chaining)
//   7     &&             left    Logical AND (short-circuit in VM)
//   8     ||             left    Logical OR (short-circuit in VM)
//
// STRING ESCAPES: \" \\ \/ \b \f \n \r \t
//
// ARCHITECTURE: The Layered Cake
//
// To ensure scalability, we strictly enforce the following hierarchy:
// 1. ATOMS:   Standalone values (numbers, strings, identifiers, (expr)).
// 2. POSTFIX: Operations that attach to the RIGHT of an atom (calls, index).
// 3. POWER:   Right-associative exponentiation (2^3^2 = 512).
// 4. PREFIX:  Operations that attach to the LEFT (negation, not).
// 5. INFIX:   Binary operators with standard precedence.
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// ============================================================================
// LAYER 1: ATOMS (The Building Blocks)
// ============================================================================
// RULE: Atoms must be self-contained. They NEVER consume surrounding operators.
// FUTURE: Add list_literal [...] and map_literal { ... } here.

integer    = @{ ASCII_DIGIT+ }
decimal    = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
number     = @{ "-"? ~ (decimal | integer) }

identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Reserved keywords (cannot be used as identifiers)
keyword    = @{
    ("let" | "mut" | "print" | "true" | "false" | "nil" | "if" | "else" | "while" | "fn" | "return" | "break" | "continue" | "forever" | "for" | "in" | "public" | "witness" | "prove")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

// 1. Define Literals
nil_lit   = { !identifier ~ "nil" }
true_lit  = { !identifier ~ "true" }
false_lit = { !identifier ~ "false" }
list_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ ","? ~ "]" }
map_pair     = { (identifier | string) ~ ":" ~ expr }
map_literal  = { "{" ~ (map_pair ~ ("," ~ map_pair)*)? ~ ","? ~ "}" }

// 2. Control Flow Expressions
block = { "{" ~ (stmt ~ stmt_terminator?)* ~ "}" }
if_expr = { !identifier ~ "if" ~ expr ~ block ~ ("else" ~ (block | if_expr))? }
while_expr = { !identifier ~ "while" ~ expr ~ block }
range_expr = { integer ~ ".." ~ integer }
for_expr   = { !identifier ~ "for" ~ identifier ~ "in" ~ (range_expr | expr) ~ block }
forever_expr = { !identifier ~ "forever" ~ block }
prove_expr = { !identifier ~ "prove" ~ block }

// 3. Function Definition (parsed as expression for first-class functions)
param_list = { identifier ~ ("," ~ identifier)* }
fn_expr = { !identifier ~ "fn" ~ identifier? ~ "(" ~ param_list? ~ ")" ~ block }

atom = {
  | nil_lit
  | true_lit
  | false_lit
  | list_literal
  | map_literal
  | if_expr
  | while_expr
  | for_expr
  | forever_expr
  | prove_expr
  | fn_expr
  | block
  | number
  | string
  | identifier
  | "(" ~ expr ~ ")"
}

// String literal con soporte de escapes
string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char* }
char   = {
    // 1. Cualquier cosa que NO sea comilla ni barra invertida
    !("\"" | "\\") ~ ANY
    // 2. Secuencias de escape comunes
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}

// ============================================================================
// LAYER 2: POSTFIX EXPRESSIONS (The Chaining Layer)
// ============================================================================
// RULE: This rule defines "Subject + Suffixes".
// It matches an Atom followed by ZERO or more suffixes.
// SCALABILITY: When adding function calls `()` or indexing `[]`, add them to 
// search `postfix_op` below (commented out for now).
// 2. POSTFIX: Operations that attach to the RIGHT of an atom (calls, index).
// ----------------------------------------------------------------------------
postfix_expr = { atom ~ (postfix_op)* }

postfix_op = _{ 
   call_op 
   | index_op 
}

index_op = { "[" ~ expr ~ "]" | "." ~ identifier }

call_op = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

// ============================================================================
// LAYER 3: POWER EXPRESSIONS (highest infix precedence, before prefix)
// ============================================================================
// Power binds tighter than prefix so `-a^2` means `-(a^2)`.

pow_op = { "^" }
pow_expr = { postfix_expr ~ (pow_op ~ postfix_expr)* }  // right-associative (handled in AST builder)

// ============================================================================
// LAYER 4: PREFIX EXPRESSIONS (Unary Operators)
// ============================================================================
// RULE: Operators that attach to the LEFT of a pow expression.
// `-a^2` → `-(a^2)` following standard math convention.

unary_op = { "-" | "!" }
prefix_expr = { unary_op* ~ pow_expr }

// ============================================================================
// LAYER 5: INFIX EXPRESSIONS (Binary Operators)
// ============================================================================
// RULE: Standard mathematical precedence.
// Evaluated from top (highest precedence) to bottom (lowest).

// Multiplicative
mul_op = { "*" | "/" | "%" }
mul_expr = { prefix_expr ~ (mul_op ~ prefix_expr)* }

// Additive
add_op = { "+" | "-" }
add_expr = { mul_expr ~ (add_op ~ mul_expr)* }

// Comparison (multi-char ops first to avoid prefix ambiguity)
// Limited to at most ONE comparison to prevent silent bugs from `a < b < c`.
cmp_op = { "!=" | "<=" | ">=" | "==" | "<" | ">" }
cmp_expr = { add_expr ~ (cmp_op ~ add_expr)? }

// Logical AND
and_op = { "&&" }
and_expr = { cmp_expr ~ (and_op ~ cmp_expr)* }

// Logical OR (lowest precedence)
or_op = { "||" }
or_expr = { and_expr ~ (or_op ~ and_expr)* }

// ROOT EXPRESSION RULE
// Points to the lowest precedence rule.
expr = { or_expr }

// ============================================================================
// STATEMENTS & PROGRAM
// ============================================================================

let_decl   = { !identifier ~ "let" ~ identifier ~ "=" ~ expr }
mut_decl   = { !identifier ~ "mut" ~ identifier ~ "=" ~ expr }
assignment = { postfix_expr ~ "=" ~ expr }
print_stmt = { !identifier ~ "print" ~ "(" ~ expr ~ ")" }
// expr_stmt  = { expr } // Removed, direct expr in stmt
break_stmt = { !identifier ~ "break" }
continue_stmt = { !identifier ~ "continue" }
array_size    = { "[" ~ integer ~ "]" }
public_decl   = { !identifier ~ "public" ~ identifier ~ array_size? ~ ("," ~ identifier ~ array_size?)* }
witness_decl  = { !identifier ~ "witness" ~ identifier ~ array_size? ~ ("," ~ identifier ~ array_size?)* }

// Named function declaration (statement, not expression)
fn_decl = { !identifier ~ "fn" ~ identifier ~ "(" ~ param_list? ~ ")" ~ block }

stmt = {
    public_decl
  | witness_decl
  | fn_decl
  | let_decl
  | mut_decl
  | assignment
  | print_stmt
  | return_stmt
  | break_stmt
  | continue_stmt
  | expr
}

return_stmt = { !identifier ~ "return" ~ expr? }

// Optional semicolon support for hygiene
stmt_terminator = _{ ";" }

program = { SOI ~ (stmt ~ stmt_terminator?)* ~ EOI }
