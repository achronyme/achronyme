// ============================================================================
// Achronyme Core Grammar - Foundation V1
// ============================================================================
// ARCHITECTURE: The Layered Cake
// 
// To ensure scalability, we strictly enforce the following hierarchy:
// 1. ATOMS:   Standalone values (numbers, strings, identifiers, (expr)).
// 2. POSTFIX: Operations that attach to the RIGHT of an atom (calls, index).
// 3. PREFIX:  Operations that attach to the LEFT (negation, not).
// 4. INFIX:   Binary operators with standard precedence.
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// ============================================================================
// LAYER 1: ATOMS (The Building Blocks)
// ============================================================================
// RULE: Atoms must be self-contained. They NEVER consume surrounding operators.
// FUTURE: Add list_literal [...] and map_literal { ... } here.

integer    = @{ ASCII_DIGIT+ }
decimal    = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
number     = @{ "-"? ~ (decimal | integer) }

// Placeholder for Complex numbers (e.g., 3i). Treated as an atom for safety.
complex    = @{ number ~ "i" }

identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Reserved keywords (cannot be used as identifiers)
keyword    = @{ "let" | "mut" | "print" | "true" | "false" | "nil" }

atom = {
    complex
  | number
  | identifier
  | "(" ~ expr ~ ")"
}

// ============================================================================
// LAYER 2: POSTFIX EXPRESSIONS (The Chaining Layer)
// ============================================================================
// RULE: This rule defines "Subject + Suffixes".
// It matches an Atom followed by ZERO or more suffixes.
// SCALABILITY: When adding function calls `()` or indexing `[]`, add them to 
// search `postfix_op` below (commented out for now).
// postfix_expr = { atom ~ (postfix_op)* }
postfix_expr = { atom }

// Currently empty, but structured for expansion.
// postfix_op = _{ 
//    call_op 
//    | index_op 
// }

// Placeholder for future function calls (commented out until needed)
// call_op = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

// ============================================================================
// LAYER 3: PREFIX EXPRESSIONS (Unary Operators)
// ============================================================================
// RULE: Operators that attach to the LEFT of a postfix expression.

unary_op = { "-" } // Future: Add "!" here
prefix_expr = { unary_op* ~ postfix_expr }

// ============================================================================
// LAYER 4: INFIX EXPRESSIONS (Binary Operators)
// ============================================================================
// RULE: Standard mathematical precedence.
// Evaluated from top (highest precedence) to bottom (lowest).

// Power (Right associative)
pow_op = { "^" }
pow_expr = { prefix_expr ~ (pow_op ~ prefix_expr)* }

// Multiplicative
mul_op = { "*" | "/" | "%" }
mul_expr = { pow_expr ~ (mul_op ~ pow_expr)* }

// Additive
add_op = { "+" | "-" }
add_expr = { mul_expr ~ (add_op ~ mul_expr)* }

// Comparison (Future)
// cmp_op = { "==" | "!=" | ... }
// cmp_expr = { add_expr ~ (cmp_op ~ add_expr)* }

// ROOT EXPRESSION RULE
// Points to the lowest precedence rule.
expr = { add_expr }

// ============================================================================
// STATEMENTS & PROGRAM
// ============================================================================

let_decl   = { "let" ~ identifier ~ "=" ~ expr }
mut_decl   = { "mut" ~ identifier ~ "=" ~ expr }
assignment = { identifier ~ "=" ~ expr }
print_stmt = { "print" ~ "(" ~ expr ~ ")" }
expr_stmt  = { expr }

stmt = {
    let_decl
  | mut_decl
  | assignment
  | print_stmt
  | expr_stmt
}

// Optional semicolon support for hygiene
stmt_terminator = _{ ";" }

program = { SOI ~ (stmt ~ stmt_terminator?)* ~ EOI }
