// Higher-order functions: map, filter, reduce, compose, apply, combinators

// --- map ---
fn map_list(arr, f) {
    mut result = []
    for x in arr {
        push(result, f(x))
    }
    return result
}
let doubled = map_list([1, 2, 3, 4, 5], fn(x) { x * 2 })
assert(len(doubled) == 5)
assert(doubled[0] == 2)
assert(doubled[4] == 10)

let negated = map_list([10, -5, 3], fn(x) { -x })
assert(negated[0] == -10)
assert(negated[1] == 5)
assert(negated[2] == -3)

let strings = map_list([1, 2, 3], fn(x) { "" + x })
assert(strings[0] == "1")
assert(strings[1] == "2")

// map on empty array
let empty = map_list([], fn(x) { x })
assert(len(empty) == 0)

// --- filter ---
fn filter(arr, pred) {
    mut result = []
    for x in arr {
        if pred(x) {
            push(result, x)
        }
    }
    return result
}
let evens = filter([1, 2, 3, 4, 5, 6, 7, 8], fn(x) { x % 2 == 0 })
assert(len(evens) == 4)
assert(evens[0] == 2)
assert(evens[1] == 4)
assert(evens[2] == 6)
assert(evens[3] == 8)

let positives = filter([-3, -1, 0, 1, 3], fn(x) { x > 0 })
assert(len(positives) == 2)
assert(positives[0] == 1)
assert(positives[1] == 3)

// filter everything
let none = filter([1, 2, 3], fn(x) { false })
assert(len(none) == 0)

// filter nothing
let all = filter([1, 2, 3], fn(x) { true })
assert(len(all) == 3)

// --- reduce (fold left) ---
fn reduce(arr, init, f) {
    mut acc = init
    for x in arr {
        acc = f(acc, x)
    }
    return acc
}
assert(reduce([1, 2, 3, 4, 5], 0, fn(a, b) { a + b }) == 15)
assert(reduce([1, 2, 3, 4, 5], 1, fn(a, b) { a * b }) == 120)
assert(reduce([3, 1, 4, 1, 5], 0, fn(a, b) { if b > a { b } else { a } }) == 5)

// reduce on single element
assert(reduce([42], 0, fn(a, b) { a + b }) == 42)

// reduce on empty array
assert(reduce([], 99, fn(a, b) { a + b }) == 99)

// --- compose ---
fn compose(f, g) {
    return fn(x) { f(g(x)) }
}
let add1 = fn(x) { x + 1 }
let mul3 = fn(x) { x * 3 }
let add1_then_mul3 = compose(mul3, add1)
assert(add1_then_mul3(4) == 15)

// Compose chain
let quad = compose(compose(fn(x) { x * 2 }, fn(x) { x * 2 }), fn(x) { x })
assert(quad(3) == 12)

// --- apply_n: apply function n times ---
fn apply_n(f, x, n) {
    mut result = x
    mut i = 0
    while i < n {
        result = f(result)
        i = i + 1
    }
    return result
}
assert(apply_n(fn(x) { x * 2 }, 1, 10) == 1024)
assert(apply_n(fn(x) { x + 1 }, 0, 100) == 100)
assert(apply_n(fn(x) { x }, 42, 1000) == 42)
assert(apply_n(fn(x) { x * 2 }, 1, 0) == 1)

// --- zip ---
fn zip(a, b) {
    mut result = []
    mut i = 0
    let length = if len(a) < len(b) { len(a) } else { len(b) }
    while i < length {
        push(result, [a[i], b[i]])
        i = i + 1
    }
    return result
}
let zipped = zip([1, 2, 3], ["a", "b", "c"])
assert(len(zipped) == 3)
assert(zipped[0][0] == 1)
assert(zipped[0][1] == "a")
assert(zipped[2][0] == 3)
assert(zipped[2][1] == "c")

// uneven zip
let short = zip([1, 2], [10, 20, 30])
assert(len(short) == 2)

// --- find ---
fn find(arr, pred) {
    for x in arr {
        if pred(x) { return x }
    }
    return nil
}
assert(find([1, 2, 3, 4], fn(x) { x > 2 }) == 3)
assert(find([1, 2, 3], fn(x) { x > 10 }) == nil)
assert(find([], fn(x) { true }) == nil)

// --- any / every ---
fn any(arr, pred) {
    for x in arr {
        if pred(x) { return true }
    }
    return false
}
fn every(arr, pred) {
    for x in arr {
        if !pred(x) { return false }
    }
    return true
}
assert(any([1, 2, 3], fn(x) { x == 2 }))
assert(!any([1, 2, 3], fn(x) { x == 5 }))
assert(every([2, 4, 6], fn(x) { x % 2 == 0 }))
assert(!every([2, 4, 5], fn(x) { x % 2 == 0 }))
assert(every([], fn(x) { false }))
assert(!any([], fn(x) { true }))

// --- flat_map ---
fn flat_map(arr, f) {
    mut result = []
    for x in arr {
        let inner = f(x)
        for y in inner {
            push(result, y)
        }
    }
    return result
}
let expanded = flat_map([1, 2, 3], fn(x) { [x, x * 10] })
assert(len(expanded) == 6)
assert(expanded[0] == 1)
assert(expanded[1] == 10)
assert(expanded[2] == 2)
assert(expanded[3] == 20)

// --- take_while ---
fn take_while(arr, pred) {
    mut result = []
    for x in arr {
        if !pred(x) { return result }
        push(result, x)
    }
    return result
}
let taken = take_while([1, 2, 3, 10, 4, 5], fn(x) { x < 5 })
assert(len(taken) == 3)
assert(taken[0] == 1)
assert(taken[2] == 3)

// --- Chaining higher-order functions ---
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result = reduce(
    map_list(
        filter(data, fn(x) { x % 2 == 0 }),
        fn(x) { x * x }
    ),
    0,
    fn(a, b) { a + b }
)
// evens: [2, 4, 6, 8, 10], squared: [4, 16, 36, 64, 100], sum: 220
assert(result == 220)

print("PASS: functions/higher_order")
