// Scoping: block scope, shadowing, nested

// Block shadow: inner let shadows outer
let x = 1
let w = {
    let x = 2
    x
}
assert(x == 1)
assert(w == 2)

// Nested 3 levels of shadowing
let a = 10
let r1 = {
    let a = 20
    let r2 = {
        let a = 30
        a
    }
    assert(a == 20)
    r2
}
assert(a == 10)
assert(r1 == 30)

// Function param doesn't leak
fn double(n) {
    return n * 2
}
assert(double(5) == 10)
// n is not visible here (would cause compile error)

// Loop variable scope â€” while counter visible outside (since it's declared outside)
mut idx = 0
while idx < 3 {
    idx = idx + 1
}
assert(idx == 3)

// Closure captures outer scope
let outer = 100
let read = fn() { outer }
assert(read() == 100)

// Same name in sibling blocks (independent)
let b1 = {
    let tmp = 1
    tmp
}
let b2 = {
    let tmp = 2
    tmp
}
assert(b1 == 1)
assert(b2 == 2)

// Mut variable modified inside block
mut counter = 0
{
    counter = counter + 1
    counter = counter + 1
}
assert(counter == 2)

// Shadow with different type
let v = 42
let v2 = {
    let v = "hello"
    v
}
assert(v == 42)
assert(v2 == "hello")

print("PASS: variables/scoping")
