// fn, closures, recursion

// Named function (via let binding)
let add = fn(a, b) {
    return a + b
}
assert(add(3, 4) == 7)

// Recursive fibonacci (named fn expr for self-reference)
let fib = fn fib(n) {
    if n < 2 { return n }
    return fib(n - 1) + fib(n - 2)
}
assert(fib(0) == 0)
assert(fib(1) == 1)
assert(fib(10) == 55)

// Early return
let abs = fn(x) {
    if x >= 0 { return x }
    return -x
}
assert(abs(5) == 5)
assert(abs(-5) == 5)

// Zero-arg function
let greet = fn() {
    return "hello"
}
assert(greet() == "hello")

// Anonymous function
let double = fn(x) { x * 2 }
assert(double(5) == 10)

// Closures capturing upvalues
let make_adder = fn(n) {
    return fn(x) { x + n }
}
let add5 = make_adder(5)
let add10 = make_adder(10)
assert(add5(3) == 8)
assert(add10(3) == 13)

// Factory pattern (make_counter)
let make_counter = fn() {
    mut count = 0
    return fn() {
        count = count + 1
        return count
    }
}
let counter = make_counter()
assert(counter() == 1)
assert(counter() == 2)
assert(counter() == 3)

// Higher-order: fn as argument
let apply = fn(f, x) {
    return f(x)
}
assert(apply(fn(x) { x * x }, 5) == 25)

// fn returning fn
let compose = fn(f, g) {
    return fn(x) { f(g(x)) }
}
let inc = fn(x) { x + 1 }
let dbl = fn(x) { x * 2 }
let inc_then_dbl = compose(dbl, inc)
assert(inc_then_dbl(3) == 8)

print("PASS: functions")
