// Prove block: secret voting circuit (eligibility + uniqueness + validity)

// --- Setup: compute test vectors in VM mode ---
let secret = 0p42
let election_id = 0p1001
let vote = 0p1

// Voter commitments
let commitment = poseidon(secret, 0)
let voter1 = poseidon(0p111, 0p0)
let voter2 = poseidon(0p222, 0p0)
let voter3 = poseidon(0p333, 0p0)

// Build depth-2 Merkle tree
let n0 = poseidon(commitment, voter1)
let n1 = poseidon(voter2, voter3)
let merkle_root = poseidon(n0, n1)

// Nullifier
let nullifier = poseidon(secret, election_id)

// Merkle proof for voter 0 (index 0, binary 00)
let path_0 = voter1
let path_1 = n1
let indices_0 = 0p0
let indices_1 = 0p0

// --- Prove block ---
prove {
    public merkle_root
    public nullifier
    public vote
    public election_id
    witness secret
    witness path[2]
    witness indices[2]

    let commitment = poseidon(secret, 0)
    merkle_verify(merkle_root, commitment, path, indices)

    let expected_nullifier = poseidon(secret, election_id)
    assert_eq(expected_nullifier, nullifier)

    range_check(vote, 1)
}

print("PASS: prove_secret_vote")
