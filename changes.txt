diff --git a/compiler/src/codegen.rs b/compiler/src/codegen.rs
index e0126eb..1308c91 100644
--- a/compiler/src/codegen.rs
+++ b/compiler/src/codegen.rs
@@ -21,20 +21,38 @@ pub struct Compiler {
     pub bytecode: Vec<u32>, // Using u32 for 4-byte instructions
     pub constants: Vec<Value>,
 
+    // Global Symbol Table (Name -> Index)
+    pub global_symbols: HashMap<String, u16>,
+    pub next_global_idx: u16,
+
     // Simple register allocator state
-    reg_top: u8,
+    pub reg_top: u8,
 
     // String Interner
     pub interner: StringInterner,
 }
 
+use vm::specs::{NATIVE_TABLE, USER_GLOBAL_START};
+
 impl Compiler {
     pub fn new() -> Self {
+        let mut global_symbols = HashMap::new();
+
+        // Phase 1: Pre-populate Natives (Must align with VM)
+        // Dynamic Population from SSOT
+        for (index, meta) in NATIVE_TABLE.iter().enumerate() {
+            global_symbols.insert(meta.name.to_string(), index as u16);
+        }
+
+        let next_global_idx = USER_GLOBAL_START; // Start user globals after natives
+
         Self {
             locals: Vec::new(),
             scope_depth: 0,
             bytecode: Vec::new(),
             constants: Vec::new(),
+            global_symbols,
+            next_global_idx,
             reg_top: 0,
             interner: StringInterner::new(),
         }
@@ -86,11 +104,22 @@ impl Compiler {
 
                 let val_reg = self.compile_expr(expr)?;
 
-                let handle = self.intern_string(&name);
-                let name_idx = self.add_constant(Value::string(handle));
+                // Allocate slot or use existing?
+                // For now: Always allocate new slot.
+                // Note: This simple approach leaks slots if you re-declare 'x' in REPL
+                // but keeps implementation simple for O(1).
 
-                // DefGlobalLet R[val_reg], Name[name_idx]
-                self.emit_abx(OpCode::DefGlobalLet, val_reg, name_idx as u16);
+                if self.next_global_idx == u16::MAX {
+                    return Err(CompilerError::TooManyConstants); // Reuse error or make new one
+                }
+
+                let idx = self.next_global_idx;
+                self.next_global_idx += 1;
+                self.global_symbols.insert(name, idx);
+
+                // DefGlobalLet R[val_reg], Slot[idx]
+                // Bx is now raw index, NOT constant pool index
+                self.emit_abx(OpCode::DefGlobalLet, val_reg, idx);
             }
             Rule::mut_decl => {
                 let mut p = inner.into_inner();
@@ -98,11 +127,17 @@ impl Compiler {
                 let expr = p.next().unwrap();
 
                 let val_reg = self.compile_expr(expr)?;
-                let handle = self.intern_string(&name);
-                let name_idx = self.add_constant(Value::string(handle));
+
+                if self.next_global_idx == u16::MAX {
+                    return Err(CompilerError::TooManyConstants);
+                }
+
+                let idx = self.next_global_idx;
+                self.next_global_idx += 1;
+                self.global_symbols.insert(name, idx);
 
                 // DefGlobalVar
-                self.emit_abx(OpCode::DefGlobalVar, val_reg, name_idx as u16);
+                self.emit_abx(OpCode::DefGlobalVar, val_reg, idx);
             }
             Rule::assignment => {
                 let mut p = inner.into_inner();
@@ -110,11 +145,15 @@ impl Compiler {
                 let expr = p.next().unwrap();
 
                 let val_reg = self.compile_expr(expr)?;
-                let handle = self.intern_string(&name);
-                let name_idx = self.add_constant(Value::string(handle));
+
+                // Lookup global index
+                let idx = *self.global_symbols.get(&name).ok_or_else(|| {
+                    // This is now a COMPILER ERROR, not runtime!
+                    CompilerError::UnknownOperator(format!("Undefined global variable: {}", name))
+                })?;
 
                 // SetGlobal
-                self.emit_abx(OpCode::SetGlobal, val_reg, name_idx as u16);
+                self.emit_abx(OpCode::SetGlobal, val_reg, idx);
             }
             Rule::print_stmt => {
                 let expr = inner.into_inner().next().unwrap();
@@ -123,10 +162,12 @@ impl Compiler {
                 let func_reg = self.alloc_reg()?;
                 let arg_reg = self.alloc_reg()?; // Must be func_reg + 1
 
-                // 2. Load "print"
-                let handle = self.intern_string("print");
-                let name_idx = self.add_constant(Value::string(handle));
-                self.emit_abx(OpCode::GetGlobal, func_reg, name_idx as u16);
+                // 2. Load "print" (Pre-defined at index 0)
+                let print_idx = *self
+                    .global_symbols
+                    .get("print")
+                    .expect("Natives not initialized");
+                self.emit_abx(OpCode::GetGlobal, func_reg, print_idx);
 
                 // 3. Compile Argument
                 let expr_reg = self.compile_expr(expr)?;
@@ -135,8 +176,6 @@ impl Compiler {
                 self.emit_abc(OpCode::Move, arg_reg, expr_reg, 0);
 
                 // 5. Call
-                // Call(Dest=func_reg, Func=func_reg, ArgCount=1)
-                // Args start at B+1 (arg_reg)
                 self.emit_abc(OpCode::Call, func_reg, func_reg, 1);
             }
             Rule::expr_stmt => {
@@ -156,9 +195,9 @@ impl Compiler {
     fn compile_expr(&mut self, pair: Pair<Rule>) -> Result<u8, CompilerError> {
         match pair.as_rule() {
             Rule::expr => self.compile_expr(pair.into_inner().next().unwrap()),
-            Rule::add_expr => self.compile_binary(pair, OpCode::Add, OpCode::Sub),
-            Rule::mul_expr => self.compile_binary(pair, OpCode::Mul, OpCode::Div),
-            Rule::pow_expr => self.compile_binary(pair, OpCode::Pow, OpCode::Nop),
+            Rule::add_expr => self.compile_binary(pair, OpCode::Add, OpCode::Sub, false),
+            Rule::mul_expr => self.compile_binary(pair, OpCode::Mul, OpCode::Div, false),
+            Rule::pow_expr => self.compile_binary(pair, OpCode::Pow, OpCode::Nop, true),
             Rule::prefix_expr => self.compile_prefix(pair),
             Rule::postfix_expr => self.compile_postfix(pair),
             Rule::atom => self.compile_atom(pair),
@@ -183,25 +222,68 @@ impl Compiler {
         pair: Pair<Rule>,
         op1: OpCode,
         op2: OpCode,
+        is_right_associative: bool,
     ) -> Result<u8, CompilerError> {
-        let mut pairs = pair.into_inner();
-        let mut left_reg = self.compile_expr(pairs.next().unwrap())?;
-
-        while let Some(op_pair) = pairs.next() {
-            let right_pair = pairs.next().ok_or(CompilerError::MissingOperand)?;
-            let right_reg = self.compile_expr(right_pair)?;
-
-            let opcode = match op_pair.as_str() {
-                "+" | "*" | "^" => op1,
-                "-" | "/" => op2,
-                _ => return Err(CompilerError::UnknownOperator(op_pair.as_str().to_string())),
-            };
-
-            let res_reg = self.alloc_reg()?;
-            self.emit_abc(opcode, res_reg, left_reg, right_reg);
-            left_reg = res_reg;
+        if is_right_associative {
+            // Right-associative (e.g., Power: 2^3^2 = 2^(3^2))
+            let mut pairs = pair.into_inner();
+            let first_pair = pairs.next().unwrap();
+
+            // 1. Collect all operands (registers)
+            let mut regs = vec![self.compile_expr(first_pair)?];
+            let mut ops = Vec::new();
+
+            // 2. Collect all operators and subsequent operands
+            while let Some(op_pair) = pairs.next() {
+                let right_pair = pairs.next().ok_or(CompilerError::MissingOperand)?;
+
+                let opcode = match op_pair.as_str() {
+                    "+" | "*" | "^" => op1,
+                    "-" | "/" => op2,
+                    _ => return Err(CompilerError::UnknownOperator(op_pair.as_str().to_string())),
+                };
+
+                ops.push(opcode);
+                regs.push(self.compile_expr(right_pair)?);
+            }
+
+            // 3. Fold Right-to-Left
+            if ops.is_empty() {
+                return Ok(regs[0]);
+            }
+
+            let mut right_reg = regs.pop().unwrap(); // Start with the last operand
+
+            // Iterate backwards through operators
+            while let Some(op) = ops.pop() {
+                let left_reg = regs.pop().unwrap();
+                let res_reg = self.alloc_reg()?;
+                self.emit_abc(op, res_reg, left_reg, right_reg);
+                right_reg = res_reg; // Result becomes the right operand for the next op
+            }
+
+            Ok(right_reg)
+        } else {
+            // Left-associative (Standard: 1-2-3 = (1-2)-3)
+            let mut pairs = pair.into_inner();
+            let mut left_reg = self.compile_expr(pairs.next().unwrap())?;
+
+            while let Some(op_pair) = pairs.next() {
+                let right_pair = pairs.next().ok_or(CompilerError::MissingOperand)?;
+                let right_reg = self.compile_expr(right_pair)?;
+
+                let opcode = match op_pair.as_str() {
+                    "+" | "*" | "^" => op1,
+                    "-" | "/" => op2,
+                    _ => return Err(CompilerError::UnknownOperator(op_pair.as_str().to_string())),
+                };
+
+                let res_reg = self.alloc_reg()?;
+                self.emit_abc(opcode, res_reg, left_reg, right_reg);
+                left_reg = res_reg;
+            }
+            Ok(left_reg)
         }
-        Ok(left_reg)
     }
 
     fn compile_prefix(&mut self, pair: Pair<Rule>) -> Result<u8, CompilerError> {
@@ -231,7 +313,7 @@ impl Compiler {
         // But we have the value in 'reg'. We just wrap it.
         // If we have [- , -], we do neg(neg(val)).
         for _op in ops {
-            // Check op type if we have more than one (e.g. !)
+            // Check op type if we have more than one (e.g. ! or -)
             // currently only "-"
             let new_reg = self.alloc_reg()?;
             self.emit_abc(OpCode::Neg, new_reg, reg, 0); // Neg uses B reg
@@ -247,7 +329,6 @@ impl Compiler {
         let atom_pair = inner.next().unwrap();
         let mut reg = self.compile_expr(atom_pair)?; // Compile the atom
 
-        // Handle suffixes (calls, index)
         // Handle suffixes (calls, index)
         if let Some(op) = inner.next() {
             match op.as_rule() {
@@ -272,9 +353,14 @@ impl Compiler {
             Rule::identifier => {
                 let name = inner.as_str().to_string();
                 let reg = self.alloc_reg()?;
-                let handle = self.intern_string(&name);
-                let name_idx = self.add_constant(Value::string(handle));
-                self.emit_abx(OpCode::GetGlobal, reg, name_idx as u16);
+
+                // Lookup global index
+                let idx = *self.global_symbols.get(&name).ok_or_else(|| {
+                    CompilerError::UnknownOperator(format!("Undefined global variable: {}", name))
+                })?;
+
+                // GetGlobal R[reg], Slot[idx]
+                self.emit_abx(OpCode::GetGlobal, reg, idx);
                 Ok(reg)
             }
             Rule::expr => self.compile_expr(inner),
diff --git a/memory/src/heap.rs b/memory/src/heap.rs
index cbcc232..672a8b2 100644
--- a/memory/src/heap.rs
+++ b/memory/src/heap.rs
@@ -185,7 +185,7 @@ impl Heap {
                         // For Map, we need to trace values. Keys are strings (implied marked if we trace keys?)
                         // If keys are interned strings managed by heap, we must mark them too!
                         if let Some(m) = self.maps.data.get(handle as usize) {
-                            for (k, v) in m.iter() {
+                            for (_k, v) in m.iter() {
                                 worklist.push(v.clone());
                                 // We might need to mark the string key if it's dynamic?
                                 // Currently keys are String in HashMap<String, Value>.
diff --git a/vm/src/lib.rs b/vm/src/lib.rs
index e686203..bce9f47 100644
--- a/vm/src/lib.rs
+++ b/vm/src/lib.rs
@@ -9,4 +9,5 @@ pub use machine::{CallFrame, VM};
 pub use opcode::OpCode;
 pub mod native;
 pub use native::{NativeFn, NativeObj};
+pub mod specs;
 pub mod stdlib;
diff --git a/vm/src/machine/gc.rs b/vm/src/machine/gc.rs
index 81b655f..3f0c94b 100644
--- a/vm/src/machine/gc.rs
+++ b/vm/src/machine/gc.rs
@@ -29,7 +29,7 @@ impl GarbageCollector for super::vm::VM {
         roots.extend_from_slice(&self.stack);
 
         // 2. Globals
-        for entry in self.globals.values() {
+        for entry in &self.globals {
             roots.push(entry.value);
         }
 
diff --git a/vm/src/machine/globals.rs b/vm/src/machine/globals.rs
index da69d1c..9e338d2 100644
--- a/vm/src/machine/globals.rs
+++ b/vm/src/machine/globals.rs
@@ -1,6 +1,7 @@
 use crate::error::RuntimeError;
 use crate::globals::GlobalEntry;
 use crate::opcode::{instruction::*, OpCode};
+use memory::Value;
 
 use super::stack::StackOps;
 
@@ -21,101 +22,66 @@ impl GlobalOps for super::vm::VM {
         op: OpCode,
         instruction: u32,
         base: usize,
-        closure_idx: u32,
+        _closure_idx: u32,
     ) -> Result<(), RuntimeError> {
-        // Get function from heap
-        let func = self
-            .heap
-            .get_function(closure_idx)
-            .ok_or(RuntimeError::FunctionNotFound)?;
+        // We no longer need 'func' to get constants, because Bx is a raw index
+        let bx = decode_bx(instruction) as usize;
 
         match op {
             OpCode::DefGlobalVar | OpCode::DefGlobalLet => {
                 let a = decode_a(instruction) as usize;
-                let bx = decode_bx(instruction) as usize;
                 let val = self.get_reg(base, a);
+                let mutable = op == OpCode::DefGlobalVar;
 
-                let c = func.constants.get(bx).ok_or(RuntimeError::InvalidOperand)?;
-                if !c.is_string() {
-                    return Err(RuntimeError::TypeMismatch(
-                        "Global name must be a string handle".into(),
-                    ));
+                // Ensure capacity
+                if bx >= self.globals.len() {
+                    // Resize to fit. Since compiler emits sequential indices, this should be fine.
+                    // Fill gaps with Nil if any (though logic suggests sequential)
+                    self.globals.resize(
+                        bx + 1,
+                        GlobalEntry {
+                            value: Value::nil(),
+                            mutable: true, // safe default
+                        },
+                    );
                 }
-                let name_handle = c.as_handle().unwrap();
 
-                let mutable = op == OpCode::DefGlobalVar;
-                self.globals.insert(
-                    name_handle,
-                    GlobalEntry {
-                        value: val,
-                        mutable,
-                    },
-                );
+                self.globals[bx] = GlobalEntry {
+                    value: val,
+                    mutable,
+                };
             }
 
             OpCode::GetGlobal => {
                 let a = decode_a(instruction) as usize;
-                let bx = decode_bx(instruction) as usize;
-
-                let c = func.constants.get(bx).ok_or(RuntimeError::InvalidOperand)?;
-                if !c.is_string() {
-                    return Err(RuntimeError::TypeMismatch(
-                        "Global name must be a string handle".into(),
-                    ));
-                }
-                let name_handle = c.as_handle().unwrap();
-
-                if let Some(entry) = self.globals.get(&name_handle) {
-                    self.set_reg(base, a, entry.value.clone());
-                } else {
-                    let name = self
-                        .heap
-                        .get_string(name_handle)
-                        .cloned()
-                        .unwrap_or("???".to_string());
+                if bx >= self.globals.len() {
                     return Err(RuntimeError::Unknown(format!(
-                        "Undefined global variable: {}",
-                        name
+                        "Global index {} out of bounds (Uninitialized?)",
+                        bx
                     )));
                 }
+                let entry = &self.globals[bx];
+                self.set_reg(base, a, entry.value.clone());
             }
 
             OpCode::SetGlobal => {
                 let a = decode_a(instruction) as usize;
-                let bx = decode_bx(instruction) as usize;
                 let val = self.get_reg(base, a);
 
-                let c = func.constants.get(bx).ok_or(RuntimeError::InvalidOperand)?;
-                if !c.is_string() {
-                    return Err(RuntimeError::TypeMismatch(
-                        "Global name must be a string handle".into(),
-                    ));
+                if bx >= self.globals.len() {
+                    return Err(RuntimeError::Unknown(format!(
+                        "Global index {} out of bounds (Uninitialized?)",
+                        bx
+                    )));
                 }
-                let name_handle = c.as_handle().unwrap();
 
-                if let Some(entry) = self.globals.get_mut(&name_handle) {
-                    if entry.mutable {
-                        entry.value = val;
-                    } else {
-                        let name = self
-                            .heap
-                            .get_string(name_handle)
-                            .cloned()
-                            .unwrap_or("???".to_string());
-                        return Err(RuntimeError::Unknown(format!(
-                            "Cannot assign to immutable global '{}'",
-                            name
-                        )));
-                    }
+                let entry = &mut self.globals[bx];
+                if entry.mutable {
+                    entry.value = val;
                 } else {
-                    let name = self
-                        .heap
-                        .get_string(name_handle)
-                        .cloned()
-                        .unwrap_or("???".to_string());
                     return Err(RuntimeError::Unknown(format!(
-                        "Undefined global variable: {}",
-                        name
+                        "Cannot assign to immutable global at index {}",
+                        bx
                     )));
                 }
             }
diff --git a/vm/src/machine/native.rs b/vm/src/machine/native.rs
index 1eb4179..f59952a 100644
--- a/vm/src/machine/native.rs
+++ b/vm/src/machine/native.rs
@@ -12,14 +12,11 @@ impl NativeRegistry for super::vm::VM {
     fn define_native(&mut self, name: &str, func: NativeFn, arity: isize) {
         let name_string = name.to_string();
 
-        // 1. Intern string (ensure it exists in Heap and Interner)
-        let name_handle = if let Some(&h) = self.interner.get(&name_string) {
-            h
-        } else {
+        // 1. Intern string (still needed for debugging/reflection later, but not for lookup key)
+        if !self.interner.contains_key(&name_string) {
             let h = self.heap.alloc_string(name_string.clone());
             self.interner.insert(name_string.clone(), h);
-            h
-        };
+        }
 
         // 2. Register Native Object
         let native = NativeObj {
@@ -30,22 +27,61 @@ impl NativeRegistry for super::vm::VM {
         self.natives.push(native);
         let native_idx = (self.natives.len() - 1) as u32;
 
-        // 3. Register in Globals
+        // 3. Register in Globals (Direct Push)
+        // Compiler guarantees 0=print, 1=len, etc.
         let val = Value::native(native_idx);
-        self.globals.insert(
-            name_handle,
-            GlobalEntry {
-                value: val,
-                mutable: false, // Natives are constant
-            },
-        );
+        self.globals.push(GlobalEntry {
+            value: val,
+            mutable: false, // Natives are constant
+        });
     }
 
     fn bootstrap_natives(&mut self) {
-        // Preamble: Core Intrinsics
-        self.define_native("print", crate::stdlib::core::native_print, -1);
-        self.define_native("len", crate::stdlib::core::native_len, 1);
-        self.define_native("typeof", crate::stdlib::core::native_typeof, 1);
-        self.define_native("assert", crate::stdlib::core::native_assert, 1);
+        use crate::specs::NATIVE_TABLE;
+
+        // Assert empty state to ensure alignment
+        if !self.natives.is_empty() || !self.globals.is_empty() {
+             panic!("VM must be empty before bootstrapping natives");
+        }
+
+        for meta in NATIVE_TABLE {
+            // Match the name to the actual Rust function pointer
+            let func_ptr = match meta.name {
+                "print"  => crate::stdlib::core::native_print,
+                "len"    => crate::stdlib::core::native_len,
+                "typeof" => crate::stdlib::core::native_typeof,
+                "assert" => crate::stdlib::core::native_assert,
+                _ => panic!("VM Implementation missing for native: {}", meta.name),
+            };
+
+            // Call internal define logic
+            // IMPORTANT: This creates the GlobalEntry.
+            // Since we iterate NATIVE_TABLE in order, 'print' will be pushed at index 0, matching the compiler.
+            self.define_native(meta.name, func_ptr, meta.arity);
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::VM;
+    use crate::specs::NATIVE_TABLE;
+
+    #[test]
+    fn test_native_alignment() {
+        let vm = VM::new(); 
+        
+        // Check internal vectors match SSOT
+        assert_eq!(vm.globals.len(), NATIVE_TABLE.len());
+        
+        // Check index 0 validity
+        let first_val = vm.globals[0].value;
+        assert!(first_val.is_native());
+        
+        // Check integrity of all natives
+        for (i, _meta) in NATIVE_TABLE.iter().enumerate() {
+            assert!(vm.globals[i].value.is_native());
+        }
     }
 }
diff --git a/vm/src/machine/vm.rs b/vm/src/machine/vm.rs
index 738e9c3..fe3f4e8 100644
--- a/vm/src/machine/vm.rs
+++ b/vm/src/machine/vm.rs
@@ -18,7 +18,7 @@ pub struct VM {
     pub heap: Heap,
     pub stack: Vec<Value>,
     pub frames: Vec<CallFrame>,
-    pub globals: HashMap<u32, GlobalEntry>,
+    pub globals: Vec<GlobalEntry>,
     pub interner: HashMap<String, u32>,
     pub natives: Vec<NativeObj>,
 }
@@ -30,7 +30,7 @@ impl VM {
             heap: Heap::new(),
             stack: Vec::with_capacity(2048),
             frames: Vec::with_capacity(64),
-            globals: HashMap::new(),
+            globals: Vec::with_capacity(64),
             interner: HashMap::new(),
             natives: Vec::new(),
         };
