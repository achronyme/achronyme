# Type Annotations System Audit — 2026-02-25

Audit of the gradual type system for circuits (PR #19 + soundness fixes). Covers
type annotation parsing, IR lowering with enforcement, `bool_prop` pass, and backend
constraint-skipping logic.

Workspace state: 894 tests passing, 0 failures.

---

## Summary

| Severity | Count | Open | IDs |
|----------|-------|------|-----|
| High     | 1     | 0    | ~~T-01~~ |
| Medium   | 2     | 0    | ~~T-02~~, ~~T-03~~ |
| Low      | 3     | 0    | ~~T-04~~, ~~T-05~~, ~~T-06~~ |

**All findings fixed.** 894 workspace tests passing.

---

## High (1)

### T-01: `witness x: Bool` declarations stamp type without enforcement constraint — FIXED

- **Files**: `ir/src/lower.rs` (`lower_witness_decl`, `lower_self_contained` witness loop)
- **Issue**: Both `lower_witness_decl` and the witness loop in `lower_self_contained`
  called `program.set_type(v, IrType::Bool)` for `: Bool` annotations without emitting a
  `RangeCheck(v, 1)` instruction. This stamped the SSA variable as `Bool` in `var_types`,
  which `bool_prop` seeds as proven-boolean. The R1CS and Plonkish backends then skipped
  **all** boolean enforcement constraints (`v * (1-v) = 0`) for that variable in
  downstream operations (`Mux`, `And`, `Or`, `Not`, `Assert`).

  A malicious prover could assign any field element to the witness, bypassing the
  enforcement that would normally constrain the value to `{0, 1}`.

  **Exploit scenario**:
  ```
  witness flag: Bool       // no RangeCheck emitted
  witness a: Field
  witness b: Field
  let r = mux(flag, a, b)  // bool enforcement on flag is SKIPPED
  ```
  Prover sets `flag = 5` → `r = 5*(a-b)+b = 5a - 4b` — circuit accepted.

  Same issue applied to `witness arr[N]: Bool` (array variant).

- **Resolution**: Extracted `enforce_input_type_ann()` helper. For `: Bool` annotations,
  emits `RangeCheck(v, 1)` per variable (one-time enforcement cost). Both
  `lower_witness_decl`, `lower_public_decl`, and both loops in `lower_self_contained`
  now call this helper. Tests: `soundness_witness_bool_decl_enforced`,
  `soundness_witness_bool_array_decl_enforced`, `witness_bool_decl_emits_range_check`,
  `witness_bool_array_decl_emits_range_checks`.

---

## Medium (2)

### T-02: `public x: Bool` declarations also lack enforcement — FIXED

- **Files**: `ir/src/lower.rs` (`lower_public_decl`, `lower_self_contained` public loop)
- **Issue**: Same pattern as T-01 but for public inputs. `public flag: Bool` stamped
  `IrType::Bool` without emitting a `RangeCheck(flag, 1)` constraint.

  Lower severity than T-01 because in Groth16 the verifier receives public inputs
  directly and can validate them off-chain. However:
  - The circuit itself was not self-contained — soundness depended on external validation
  - If a verification contract (on-chain) only checks the proof without validating
    public input ranges, the circuit was exploitable
  - Defense-in-depth: constraints should enforce all invariants

- **Resolution**: Fixed by the same `enforce_input_type_ann()` helper as T-01. Public
  `: Bool` declarations now emit `RangeCheck(v, 1)`. Tests:
  `soundness_public_bool_decl_enforced`, `public_bool_decl_emits_range_check`.

### T-03: Array `Bool[N]` annotation skips type compatibility check for typed elements — FIXED

- **File**: `ir/src/lower.rs` (`lower_let` array path)
- **Issue**: In the `lower_let` array path, when annotation was `Bool[N]` and an element
  already had a type, the code called `self.program.set_type(*v, elem_ty)` (where
  `elem_ty = IrType::Bool`) without checking `type_compatible(Bool, inferred)`.
  If an element was typed as `Field` (e.g., result of `a + b`), this blindly stamped
  `Bool` on it. `bool_prop` then seeded it as proven-boolean, causing the backend to
  skip boolean enforcement.

  **Exploit scenario**:
  ```
  witness a: Field
  witness b: Field
  let sum = a + b            // typed as Field
  let arr: Bool[1] = [sum]   // stamped Bool on sum, no error
  let r = mux(arr[0], a, b)  // skipped enforcement on arr[0]
  ```

- **Resolution**: Added `type_compatible(elem_ty, inferred)` check with
  `AnnotationMismatch` error for incompatible types (e.g., `Field` element in `Bool[N]`
  array). Compatible types (e.g., `Bool` element in `Bool[N]` array) are kept as-is
  without re-stamping. Test: `array_bool_annotation_rejects_field_typed_element`.

---

## Low (3)

### T-04: Scalar annotation on array / array annotation on scalar silently accepted — FIXED

- **File**: `ir/src/lower.rs` (`lower_let`)
- **Issue**: The `lower_let` function dispatches to the array path only when the RHS is
  `Expr::Array`. Type annotation shape is not validated against value shape:
  - `let x: Field[3] = expr` on scalar: `annotation_to_ir_type(FieldArray(3))` returns
    `IrType::Field`, array size `[3]` is silently ignored
  - `let arr: Bool = [x, y]` on array: `annotation_to_ir_type(Bool)` returns
    `IrType::Bool`, no array size validation occurs (since `Bool` has no size, the
    `expected_size` match returns `None`)

  Neither case produces an error. While not a soundness issue (enforcement works
  correctly in both paths), it allows confusing code to compile silently.

- **Resolution**: Added shape validation in `lower_let`: array path rejects scalar
  annotations (`Field`/`Bool`) with `TypeMismatch` error, scalar path rejects array
  annotations (`FieldArray`/`BoolArray`) with `TypeMismatch` error. Tests:
  `scalar_annotation_on_array_rejected`, `scalar_field_annotation_on_array_rejected`,
  `array_annotation_on_scalar_rejected`, `array_bool_annotation_on_scalar_rejected`.

### T-05: `pow_by_squaring` intermediate and final results untyped — FIXED

- **File**: `ir/src/lower.rs` (`pow_by_squaring`, `lower_binop` Pow path)
- **Issue**: The `pow_by_squaring` function emits `Mul` instructions for `x ^ n` but
  doesn't call `set_type(v, IrType::Field)` on intermediate or final result variables.
  All other arithmetic operations in `lower_binop` (`Add`, `Sub`, `Mul`, `Div`) set
  `IrType::Field` on their results.

  Not a soundness issue — untyped values are handled conservatively (enforcement
  constraints are always emitted). But creates an inconsistency: `x * x` produces a
  `Field`-typed result while `x ^ 2` produces an untyped result.

- **Resolution**: Added `self.program.set_type(v, IrType::Field)` after each `Mul` in
  `pow_by_squaring`, after the `Const(1)` for `exp == 0` in `pow_by_squaring`, and
  after the early `Const(1)` for `exp == 0` in the `lower_binop` Pow path. Tests:
  `pow_result_has_field_type`, `pow_zero_result_has_field_type`.

### T-06: `Field[N]` annotation overwrites `Bool` type on elements — FIXED

- **File**: `ir/src/lower.rs` (`lower_let` array path)
- **Issue**: In the `lower_let` array path for `Field[N]` annotations:
  ```rust
  for v in &vars {
      self.program.set_type(*v, elem_ty);  // elem_ty = Field
  }
  ```
  If an element was previously typed as `Bool` (e.g., from a comparison result), the
  type is widened to `Field` in `var_types`. Since `set_type` modifies the original
  SSA variable (arrays are aliases, not copies), this erases the `Bool` type for ALL
  references to that variable, not just the array element.

  `bool_prop` will no longer seed the variable as boolean from `var_types`, though it
  may still be boolean from structural analysis (e.g., comparison result). This can
  lead to unnecessary boolean enforcement constraints (extra cost, not unsound).

- **Resolution**: Changed `Field[N]` annotation loop to skip elements already typed as
  `Bool`, preserving the more specific type. Test:
  `field_array_preserves_bool_element_type`.

---

## Verified Correct (no findings)

| Area | Verification |
|------|-------------|
| `lower_let` scalar Bool enforcement | `let b: Bool = x` (untyped x) emits `RangeCheck(v, 1)` — soundness test `soundness_let_bool_on_untyped_witness_enforced` passes with malicious prover (x=5) |
| `lower_let` scalar compatibility check | `let x: Bool = a + b` returns `AnnotationMismatch` — add produces `Field`, incompatible with `Bool` |
| `lower_let` scalar Field-on-untyped | `let f: Field = x` stamps `Field`, no enforcement — safe (Field is the default type) |
| Function param Bool enforcement | `fn f(b: Bool)` called with untyped arg emits `RangeCheck` — soundness test `soundness_fn_param_bool_enforced` passes |
| Function return Bool enforcement | `fn f() -> Bool` with untyped body result emits `RangeCheck` — soundness test `soundness_fn_return_bool_enforced` passes |
| `Neg` type propagation | `-x` sets `IrType::Field` on result — test `neg_result_has_field_type` passes |
| `Not` operand validation | `!x` where `x: Field` returns `AnnotationMismatch` — prevents logical NOT on non-boolean values |
| `bool_prop` RangeCheck(x, 1) recognition | `RangeCheck` with `bits == 1` seeds result as proven-boolean — test `bool_prop_range_check_1_bit_is_boolean` passes |
| `bool_prop` Assert recognition | `Assert` seeds both operand and result as proven-boolean — test `bool_prop_assert_marks_operand_boolean` passes |
| `bool_prop` RangeCheck(x, 8) exclusion | `RangeCheck` with `bits > 1` does NOT seed as boolean — verified in test |
| Subtyping direction | `type_compatible(Field, Bool) = true` (Bool→Field OK), `type_compatible(Bool, Field) = false` (Field→Bool rejected) |
| Comparison type inference | All 6 comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) set `IrType::Bool` on result |
| Arithmetic type inference | All 4 arithmetic operators (`+`, `-`, `*`, `/`) and `Neg` set `IrType::Field` on result |
| Boolean literal types | `true` → `Const(1)` + `IrType::Bool`, `false` → `Const(0)` + `IrType::Bool` |
| DCE safety | `RangeCheck` and `Assert` have `has_side_effects = true` — survive dead code elimination |
| Const_fold boolean guards | `Not`/`And`/`Or` only fold when operands are actual 0 or 1 (checked via `is_zero()` / `== ONE`) — non-boolean constants keep the instruction so enforcement constraints are emitted |
| Array size validation | `let a: Field[2] = [x, y, z]` returns `ArrayLengthMismatch` — test `array_annotation_validates_length` passes |
| Array Bool enforcement | `let a: Bool[2] = [x, y]` (untyped elements) emits `RangeCheck` per element — test `array_bool_on_untyped_elements_enforces` passes |
| Input Bool enforcement | `witness x: Bool` and `public x: Bool` now emit `RangeCheck(v, 1)` — soundness tests pass with malicious prover values |
| R1CS boolean skip logic | Backend checks `proven_boolean.contains(var)` before emitting `v*(1-v)=0` for Mux, Not, And, Or, Assert — constraint count tests verify savings |
| Plonkish boolean skip logic | Same pattern as R1CS — `bool_prop_plonkish_reduces_rows` test verifies savings |
| Parser type annotation parsing | All 13 parser tests pass: scalars, arrays, functions, mixed params, invalid types |
| `TypeAnnotation` enum coverage | `Field`, `Bool`, `FieldArray(n)`, `BoolArray(n)` — all variants handled in lowering and display |

---

## Fix Status

| ID   | Fix | Status |
|------|-----|--------|
| T-01 | `enforce_input_type_ann()` helper emits `RangeCheck(v, 1)` for `: Bool` declarations | **DONE** |
| T-02 | Same `enforce_input_type_ann()` helper covers public declarations | **DONE** |
| T-03 | Added `type_compatible` check + `AnnotationMismatch` error in array Bool path | **DONE** |
| T-04 | `TypeMismatch` error for scalar annotation on array / array annotation on scalar | **DONE** |
| T-05 | `set_type(v, IrType::Field)` in `pow_by_squaring` + `lower_binop` Pow `exp==0` path | **DONE** |
| T-06 | `Field[N]` loop skips elements already typed as `Bool` | **DONE** |
